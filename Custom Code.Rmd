---
title: "Wooldridge 7e - Appendix B - Math Refresher - Basic Tools"
author: "Shane Kercheval"
output:
  md_document:
    variant: markdown_github
    toc: true
    toc_depth: 4
---

```{r setup, echo=FALSE, warning = FALSE, message = FALSE}
#devtools::install_github('shane-kercheval/rtools')
library(ggplot2)
library(purrr)
library(scales)
library(stringr)
library(dplyr)
library(tidyr)
library(rtools)
library(forcats)

options(scipen=999) # non-scientific notation
theme_set(theme_light())
```

```{r}
matrixpower <- function(mat,k) {
    if (k == 0) {
      
        mat_diag <- diag(dim(mat)[1])
        rownames(mat_diag) <- rownames(mat)
        colnames(mat_diag) <- colnames(mat)
        return (mat_diag)  
    }
    if (k == 1) return(mat)
    if (k > 1) return( mat %*% matrixpower(mat, k-1))
}
```


# Appendix B - Probability Review

## Example B.2

```{r}
circumference <- function(r) {
    return (pi * r ^ 2)
}
radius <- c(1, 2, 4, 8)
probabilities <- c(0.1, 0.2, 0.3, 0.4)
(expected_value <- sum(circumference(radius) * probabilities))
expected_value / pi
```

```{r}
cal_expected_value <- function(.func, .values, .probabilities) {
    return ( sum(.func(.values) * .probabilities) )
}

all.equal(expected_value, cal_expected_value(circumference, radius, probabilities))
```


```{r}
(values <- circumference(radius))
var(values)
sd(values)
(variance <- sum((radius - expected_value)^2 * probabilities))
sqrt(variance)
```

hmmm.. pg 424 says this should be equivalent to above but i'm not getting the same answer 

```{r}
cal_expected_value(circumference, radius^2, probabilities) - expected_value^2
```

## Example B.5

```{r}
rt_plot_binom <- function(.num_observations, .probability) {
    data.frame(x = 0:.num_observations,
                  y = dbinom(0:.num_observations, .num_observations, prob = .probability)) %>%
        ggplot(aes(x=x, y=y)) +
        geom_col()
}
rt_plot_binom(100, 0.8) + geom_vline(aes(xintercept = 75), color='red')

sum(dbinom(0:100, 100, 0.8))
# sum each probability from 75 to 100
sum(dbinom(75:100, 100, 0.8))
# or, take the sum of probabilities from 1 to 74 and subtract it from 1
1 - sum(dbinom(1:74, 100, 0.8))
1 - pbinom(74, 100, 0.8)
```

```{r}
rt_plot_geom <- function(.num_observations, .probability) {
    data.frame(x = .num_observations,
               y = dgeom(.num_observations - 1, prob = .probability)) %>%
        ggplot(aes(x=x, y=y)) +
    geom_col() +
    scale_x_continuous(breaks = pretty_breaks(max(.num_observations) + 1)) +
    scale_y_continuous(labels=percent_format())
}
rt_plot_geom(1:10, 0.5) 
# 52 cards, 4 aces
# how many hands until first ace
rt_plot_geom(0:51, 4/52)
1/(4/52)
```

# Example B.6

Interested to see if I can simulate this and get ~same number from book.

```{r}
first_card_ace <- rbinom(1, 1, 4/52)
second_card_ace <- rbinom(1, 1, 4/51)
any(rbinom(1, 1, 4/52), rbinom(1, 1, 4/51))

num_deals <- 100
num_simulations <- 10000
simulations <- map(1:num_simulations,
                   ~ map_lgl(1:num_deals,
                             ~ any(rbinom(1, 1, 4/52), rbinom(1, 1, 4/51))))

mean(map_dbl(simulations, ~ which(. == 1)[1]))
```

```{r}
rt_plot_poisson <- function(.num_observations, .rate) {
    data.frame(x = .num_observations,
               y = dpois(.num_observations, .rate)) %>%
        ggplot(aes(x=x, y=y)) +
    geom_col() +
    scale_x_continuous(breaks = pretty_breaks(max(.num_observations) + 1)) +
    scale_y_continuous(labels=percent_format())
}
rt_plot_poisson(0:30, 21.7) 
dpois(14, 21.7)
ppois(14, 21.7)
```

## Example B.9

```{r}
blood_type_probabilities <- c(0.44, 0.42, 0.10, 0.04)
names(blood_type_probabilities) <- c("O", "A", "B", "AB")
blood_type_probabilities

snumber_of_people <- 6
# random selection of people
rmultinom(10, size = number_of_people, prob = blood_type_probabilities)
# probability (density) that, in a sample of 6 people, 
# 3 are O, 2 are A, 1 is B, and 0 are AB
dmultinom(c(3, 2, 1, 0), prob = blood_type_probabilities)
```

## Example B.10

```{r}
# probability component will lat more than 1300 hours
1 - pexp(1300, 1/1200)

1 - pexp(1, 1/2)
1 - pexp(2, 1/4)

# if the average tv last 5 years
# what is the probability it will last at least a year
1 - pexp(1, 1/5)
# so extended warranty is for the pexp(1, 1/5) chance it will not last more than a year
pexp(1, 1/5)
```


# Chapter 1

```{r}
rt_plot_binom <- function(.num_observations, .probability) {
    as.data.frame(x = 0:.num_observations,
                  y = dbinom(x, .num_observations, prob = .probability)) %>%
        ggplot(aes(x=x, y=y)) +
        geom_col()
}

reed_frost_probability_time_t <- function(.z, .I_t) {
    return (1 - (1 - .z)^.I_t)
}

reed_frost_probability_time_t(0.004, 3)

simulate_infected_t_next <- function(.susceptible_t,
                                     .infected_t,
                                     .infection_probability) {
    # simulate each person in the susceptible group either getting (1) or
    # not getting (0) the disease based on Reed-Frost probability
    return (rbinom(n=.susceptible_t,
                   size=1,
                   prob=reed_frost_probability_time_t(.infection_probability,
                                                      .infected_t)))
}
simulate_infected_t_next(400, 3, 0.004)

simulate_t_units <- function(.time_units=20,
                             .susceptible_init=400,
                             .infected_init=3,
                             .infection_probability=0.004) {

    .susceptible_t <- numeric(.time_units + 1)
    .infected_t <- numeric(.time_units + 1)
    
    .susceptible_t[1] <- .susceptible_init
    .infected_t[1] <- .infected_init

    for(.time in 1:.time_units) {
        newly_infected <- simulate_infected_t_next(.susceptible_t[.time],
                                                   .infected_t[.time],
                                                   .infection_probability)

        .infected_t[.time + 1] <- sum(newly_infected)
        .susceptible_t[.time + 1] <- .susceptible_t[.time] - .infected_t[.time + 1]
    }
    
    return (list(infected=.infected_t,
                 susceptible=.susceptible_t))
}
```

```{r}
simulate_t_units(20, 400, 3, 0.004)$infected %>% plot(type='b')
```

```{r fig.height=6, fig.width=9}
num_time_units <- 100
many_sims <- map(1:10000, ~ simulate_t_units(num_time_units, 400, 3, 0.004)$infected)

#many_sims[[1]]
sims_matrix <- matrix(unlist(many_sims), ncol = num_time_units + 1, byrow = TRUE)
#dim(sims_matrix)
#View(sims_matrix)
sims_df <- as.data.frame(sims_matrix)
quantile_low <- function(x) {
    quantile(x, 0.025)
}
quantile_high <- function(x) {
    quantile(x, 0.975)
}

data.frame(t=0:num_time_units,
           mean_val=apply(sims_matrix, 2, mean),
           median_val=apply(sims_matrix, 2, median),
           conf_low=apply(sims_matrix, 2, quantile_low),
           conf_high=apply(sims_matrix, 2, quantile_high)) %>%
    ggplot(aes(x=t, y=median_val)) +
    geom_point() +
    geom_point(aes(y=mean_val), color='blue') +
    geom_errorbar(aes(ymin=conf_low, ymax=conf_high)) +
    scale_y_continuous(breaks = pretty_breaks(10)) +
    coord_cartesian(xlim=c(0, 25), ylim=c(0, 70))

sims_long_df <- sims_df %>%
    mutate(sim=1:nrow(sims_df)) %>%
    pivot_longer(-sim, names_to = 'time_index', values_to = 'infected') %>%
    mutate(time_index = as.numeric(str_remove(time_index, 'V')))

sims_long_df %>%
    ggplot(aes(x = time_index, y = infected, group=sim)) +
    geom_line(alpha=0.01) +
    scale_y_continuous(breaks = pretty_breaks(10)) +
    coord_cartesian(xlim=c(0, 25), ylim=c(0, 70))

sims_long_df %>%
    ggplot(aes(x = time_index, y = infected)) +
    geom_jitter(alpha=0.01) +
    scale_y_continuous(breaks = pretty_breaks(10)) +
    coord_cartesian(xlim=c(0, 25), ylim=c(0, 70))

sims_long_df %>%
    ggplot(aes(x = time_index, y = infected, group=time_index)) +
    geom_boxplot() +
    scale_y_continuous(breaks = pretty_breaks(10)) +
    coord_cartesian(xlim=c(0, 25), ylim=c(0, 70))
```

## Example 1.12

```{r fig.height=9, fig.width=12}
number_of_simulations <- 10000
X <- round(runif(number_of_simulations, min=0.50001, max=100.499999))
plot(table(X) / number_of_simulations)
Y <- map_dbl(X, ~ round(runif(1, min=0.50001, max= . + 0.499999)))
# Distribution of Y
plot(table(Y) / number_of_simulations)

data.frame(x=X, y=Y) %>%
    ggplot(aes(x=x, y=y)) +
    geom_jitter(alpha=0.5)

data.frame(x=X, y=Y) %>%
    ggplot(aes(x=x, y=y, group=x)) +
    geom_boxplot()
#sum(table(Y) / number_of_simulations)

# distribution of Y given X?
plot(1:100, 1 / (1:100), type = 'h')
```

Same thing implemented differently

```{r fig.height=9, fig.width=12}
number_of_simulations <- 10000
X <- sample(1:100, size = number_of_simulations, replace = TRUE)
plot(table(X) / number_of_simulations)
Y <- map_dbl(X, ~ sample(1:., size = 1, replace = TRUE))
# Distribution of Y
plot(table(Y) / number_of_simulations)

data.frame(x=X, y=Y) %>%
    ggplot(aes(x=x, y=y)) +
    geom_jitter(alpha=0.5)

data.frame(x=X, y=Y) %>%
    ggplot(aes(x=x, y=y, group=x)) +
    geom_boxplot()
#sum(table(Y) / number_of_simulations)

# distribution of Y given X?
plot(1:100, 1 / (1:100), type = 'h')
```

## Example 1.21

```{r}
(flips <- rbinom(100, 1, 0.5))
(rolling_sum <- rollapplyr(flips, width = 2, FUN = sum, partial = TRUE))
which(rolling_sum == 2)
```

```{r}
num_simulations <- 10000
num_flips_until_2_heads <- map_dbl(1:num_simulations, ~ which(rollapplyr(rbinom(100, 1, 0.5), width = 2, FUN = sum, partial = TRUE) == 2)[1])
mean(num_flips_until_2_heads)
hist(num_flips_until_2_heads, breaks = max(num_flips_until_2_heads))
```

Note that expecte value is `6` (i.e the average of all the simulations i.e. in the long run.), even though `2` is the most probabilistic. 

## Example 1.31

```{r fig.height=9, fig.width=12}
number_of_simulations <- 100000
X <- runif(number_of_simulations, min=0, max=1)
Y <- map_dbl(X, ~ runif(1, min=0, max= .))
# Distribution of Y

data.frame(x=X, y=Y) %>%
    ggplot(aes(x=x, y=y)) +
    geom_jitter(alpha=0.5)

mean(Y)
var(Y)
```

From Book

```{r}
trials <- 100000
simlist <- replicate(trials, runif(1, 0, runif(1)))
var(simlist)
```

## Exercise 1.35

```{r}
# gamble(k, n, p)
  #   k: Gambler's initial state
  #   n: Gambler plays until either $n or Ruin
  #   p: Probability of winning $1 at each play
  #   Function returns 1 if gambler is eventually ruined
  #                    returns 0 if gambler eventually wins $n
  
gamble <- function(k,n,p) {
	stake <- k
	while (stake > 0 & stake < n) {
		bet <- sample(c(-1,1), 1, prob=c(1-p, p))
		stake <- stake + bet
	}
	if (stake == 0) return(1) else return(0)
}   

k <- 60
n <-  100  
p <- 0.50 
trials <- 10000
simlist <- replicate(trials, gamble(k, n, p))

mean(simlist) # Estimate of probability that gambler is ruined
1 - mean(simlist)# Estimate of probability that the gambler wins $100

p <- 0.51
trials <- 10000
simlist <- replicate(trials, gamble(k, n, p))

mean(simlist) # Estimate of probability that gambler is ruined
1 - mean(simlist)# Estimate of probability that the gambler wins $100

```

# Chapter 2

```{r}
trans_matrix <- function(.names, .values) {
    P <- matrix(ncol = length(.names), 
            byrow = TRUE, dimnames = list(.names, .names),
            data=.values)
    
    stopifnot(all.equal(as.numeric(rowSums(P)), rep(1, length(.names))))
    return (P)
}
```

## Example 2.15

```{r}
P <- trans_matrix(c("Rain", "Snow", "Clear"),
                  c(0.2, 0.6, 0.2,
                    0.1, 0.8, 0.1,
                    0.1, 0.6, 0.3))
P
matrixpower(P, 2)

initial_state <- c(0.5, 0.5, 0)
(probability_day_2 <- initial_state %*% matrixpower(P, 2))
probability_day_2[1, 'Snow']
```


## Example 2.16

```{r}

P <- trans_matrix(c("B", "F", "P", "S"),
                  c(0.0, 0.5, 0.5, 0.0,
                    0.5, 0.0, 0.5, 0.0,
                    0.4, 0.0, 0.0, 0.6,
                    0.0, 0.2, 0.6, 0.2))
P
(P_2 <- matrixpower(P, 2))
(P_3 <- matrixpower(P, 3))

(alpha <- rep(0.25, 4))

(alpha %*% P_3)[1, 'S']
P_2['S', 'S']
P['S', 'P']

(alpha %*% P_3)[1, 'S'] * P_2['S', 'S'] * P['S', 'P']
```


```{r}
P_2['P', 'F']
```

## Using `markovchain` library

```{r}
library(markovchain)
weatherStates <- c("sunny", "cloudy", "rain")
weatherMatrix <- matrix(data = c(0.70, 0.2, 0.1,
                                 0.3, 0.4, 0.3,
                                 0.2, 0.45, 0.35),
                        byrow = TRUE,
                        nrow = length(weatherStates),
                        dimnames = list(weatherStates, weatherStates))
mcWeather <- new("markovchain", states = weatherStates, byrow = TRUE,
                 transitionMatrix = weatherMatrix, name = "Weather")

weatherStates <- c("sunny", "cloudy", "rain")
weatherMatrix <- trans_matrix(weatherStates,
                              c(0.70, 0.2, 0.1,
                                 0.3, 0.4, 0.3,
                                 0.2, 0.45, 0.35))
mcWeather <- new("markovchain", states = weatherStates, transitionMatrix = weatherMatrix, byrow = TRUE,
                 name = "Weather")
mcWeather
plot(mcWeather)
```

Shown below, the markovchain object changes the power operation so that it works with Matrices. It also changes the multiplication operation to dot product.

```{r}
weatherMatrix ^ 7  # not correct way
matrixpower(weatherMatrix, 7)  # correct
mcWeather ^ 7  # correct
```

```{r}
initialState <- c(0, 1, 0)
initialState * weatherMatrix  # regular multiplication
initialState %*% weatherMatrix  # dot product
initialState * mcWeather  # dot product
```

```{r}
initialState <- c(0, 1, 0)

(after2Days <- initialState * (mcWeather * mcWeather))
stopifnot(all.equal(sum(after2Days), 1))
(after7Days <- initialState * (mcWeather ^ 7))
```

```{r}
(probability_day_2 <- initialState %*% matrixpower(weatherMatrix, 2))
stopifnot(all.equal(sum(probability_day_2), 1))

(probability_day_7 <- initialState %*% matrixpower(weatherMatrix, 7))
```

```{r}
state_names <- c("Burrito", "Falafel", "Pizza", "Sushi")
P <- trans_matrix(state_names,
                  c(0.0, 0.5, 0.5, 0.0,
                    0.5, 0.0, 0.5, 0.0,
                    0.4, 0.0, 0.0, 0.6,
                    0.0, 0.2, 0.6, 0.2))
example_2_16 <- new("markovchain", byrow = TRUE,
                 states = state_names, 
                 transitionMatrix = P,
                 name = "Example")
example_2_16
plot(example_2_16)
```

```{r}
# function from https://cran.r-project.org/web/packages/markovchain/vignettes/an_introduction_to_markovchain_package.pdf
fvals <- function(mchain,initialstate,n) {
    out <- data.frame()
    names(initialstate) <- names(mchain)
    for (i in 0:n) {
        iteration <- initialstate*mchain^(i)
        out <- rbind(out,iteration)
    }
    out <- cbind(out, i=seq(0,n))
    out <- out[,c(4,1:3)]
    return(out)
}
fval_iterations_1 <- fvals(mchain=mcWeather,initialstate=c(1/3, 1/3, 1/3), n=20)
fval_iterations_2 <- fvals(mchain=mcWeather,initialstate=c(1, 0, 0), n=20)

# ~same values even though they started with different initial states
tail(fval_iterations_1, 1)
tail(fval_iterations_2, 1)
all.equal(as.numeric(tail(fval_iterations_1, 1)), as.numeric(tail(fval_iterations_2, 1)))
```

```{r}
matrixpower(P, 100)
```

```{r}
initial_state <- c(0, 0, 1, 0)
initial_state %*% P
t(P) * initial_state
    
initial_state %*% P^3

matrixpower(P, 3)
(t(P) ^ 3)
    

fvals(mchain=mcWeather,initialstate=c(90,5,5),n=4)

```


# Calculating Transition Matrix From Data

```{r}
# https://stackoverflow.com/questions/18824596/how-to-create-a-transition-matrix-in-r

# assuming the data is read into a data frame called "raindata"
raindata <- tribble(
    ~day,~month,~year,~rainfall,
    1,01,1950,0.586212158,
    2,01,1950,1.202758789,
    3,01,1950,0,
    4,01,1950,0,
    5,01,1950,0,
    6,01,1950,0.183441162,
    7,01,1950,4.675704956,
    8,01,1950,9.258003235,
    9,01,1950,3.425468445,
    10,01,1950,0,
    11,01,1950,0,
    12,01,1950,8.39233E-05,
    13,01,1950,0,
    14,01,1950,0,
    15,01,1950,0.641731262,
    16,01,1950,9.325141907,
    17,01,1950,5.588417053,
    18,01,1950,0.903343201,
    19,01,1950,3.892127991,
    20,01,1950,0.133895874,
    21,01,1950,0.102630615,
    22,01,1950,5.334564209,
    23,01,1950,1.017593384,
    24,01,1950,0,
    25,01,1950,0.621734619,
    26,01,1950,0.957794189,
    27,01,1950,3.131622314,
    28,01,1950,4.868865967,
    29,01,1950,0.169281006,
    30,01,1950,0,
    31,01,1950,0)

rf <- raindata$rainfall
n <- length(rf)
rainedf <- as.factor(ifelse(rf,0,1))
trf_df <- data.frame(yesterday=rainedf[1:(n-1)],today=rainedf[2:n])
trf_freq <- table(trf_df)
trf_prob <- trf_freq/rowSums(trf_freq)

rowSums(trf_prob)

# probability it will not rain today given it rained yesterday
# row 2 column 1
trf_prob[2, 1]
# same thing
sum(trf_df$today == 0 & trf_df$yesterday == 1) / sum(trf_df$yesterday == 1)
```


## 2.5 Simulation

```{r}
markov <- function(init, mat, n, labels) { 
    if (missing(labels)) {
        labels <- 1:length(init)
    }
        
    simlist <- numeric(n+1)
    states <- 1:length(init)
    # initial state (e.g. where the cancer starts) based on initial probability distribution
    simlist[1] <- sample(states, 1, prob=init)
    for (i in 2:(n+1)) {
        
        previous_simulation <- simlist[i-1]
        prob_distribution_given_previous <- mat[previous_simulation, ]
        # simulate currrent state (e.g. where cancer will spread next) based on previous state (where cancer spread to last)
        # based on the probability distribution for that previous state
        simlist[i] <- sample(states, 1, prob=prob_distribution_given_previous)
    }
    
    return (labels[simlist])
}
```

```{r}
P <- read.csv("original\ code/lungcancer.csv",header=T)
P <- as.matrix(P)
rownames(P) <- colnames(P)
P
init <- c(rep(0,22),1,rep(0,27)) # Starting state 23 is Lung
names(init) <- colnames(P)
num_steps <- 8
```


```{r}
long_term <- matrixpower(P, 1000)[1, ]
data.frame(long_term_percent=long_term,
           part=names(long_term)) %>%
    mutate(part = fct_reorder(part, long_term_percent)) %>%
    filter(long_term_percent > 0) %>%
    ggplot(aes(x = part, y = long_term_percent)) +
    geom_col() +
    coord_flip()
```


```{r}
(simulation <- markov(init,P,num_steps))
colnames(P)[simulation]
```

```{r}
results <- map(1:10000, ~  colnames(P)[markov(init,P,num_steps)])
```

```{r}
data.frame(part=unlist(flatten(results))) %>%
    count(part) %>%
    mutate(perc = n / sum(n)) %>%
    mutate(part = fct_reorder(part, perc)) %>%
    ggplot(aes(x = part, y = perc)) +
    geom_col() +
    coord_flip()
    #theme(axis.text.x=element_text(angle=30, hjust=1)) 
    
```

```{r}
simulations <- matrix(unlist(results), ncol = num_steps + 1, byrow = TRUE)
head(simulations)
simulations <- as.data.frame(simulations)
colnames(simulations) <- paste("Step", 1:ncol(simulations))
head(simulations)
```

```{r fig.height=6, fig.width=9}
library(tidytext)
simulations %>%
    mutate(sim_index = row_number()) %>%
    pivot_longer(-sim_index, names_to = 'step', values_to='body_part') %>%
    group_by(step, body_part) %>%
    summarise(n=n(),
              perc_n = n() / nrow(simulations)) %>%
    ungroup() %>%
    filter(step != 'Step 1') %>%
    mutate(body_part = reorder_within(body_part, n, step)) %>%
    ggplot(aes(x = body_part, y=perc_n)) + #, fill=body_part)) +
    geom_col() +
    scale_x_reordered() +
    coord_flip() +
    #scale_fill_manual(values=rep(rt_colors(), 30)) +
    theme(legend.position = 'none') +
    facet_wrap(~ step, scales = 'free')
```

```{r fig.height=6, fig.width=9}
simulations %>%
    mutate(sim_index = row_number()) %>%
    pivot_longer(-sim_index, names_to = 'step', values_to='body_part') %>%
    group_by(step, body_part) %>%
    summarise(n=n(),
              perc_n = n() / nrow(simulations)) %>%
    ungroup() %>%
    filter(step != 'Step 1') %>%
    mutate(body_part = fct_reorder(body_part, n, .fun = max)) %>%
    ggplot(aes(x = body_part, y=perc_n, fill=body_part)) +
    geom_col() +
    coord_flip() +
    scale_fill_manual(values=rep(rev(rt_colors()), 30)) +
    theme(legend.position = 'none') +
    facet_wrap(~ step, scales = 'free')
```

```{r}
markov_most_likely <- function(init, mat, n, labels) { 
    if (missing(labels)) {
        labels <- 1:length(init)
    }
        
    simlist <- numeric(n+1)
    states <- 1:length(init)
    # initial state (e.g. where the cancer starts) based on initial probability distribution
    
    #simlist[1] <- sample(states, 1, prob=init)
    simlist[1] <- which.max(init)[1]
    for (i in 2:(n+1)) {
        
        previous_simulation <- simlist[i-1]
        prob_distribution_given_previous <- mat[previous_simulation, ]
        simlist[i] <- which.max(prob_distribution_given_previous)[1]
        
        # simulate currrent state (e.g. where cancer will spread next) based on previous state (where cancer spread to last)
        # based on the probability distribution for that previous state
        #simlist[i] <- sample(states, 1, prob=prob_distribution_given_previous)
    }
    return (labels[simlist])
}

# not sure how great or useful this is, but this simply gives the most probable outcome at each step based on the previous/initial
# in reality, this exact path may or may not actually have a high chance of occuring (especially with the lung cancer example where there are many posible combinations)
diag(P) <- 0
(steps <- markov_most_likely(init,P,num_steps))
colnames(P)[steps]
# not useful...... in this example might be useful in other examples where you can't go back to previous states
```

## Example 2.19

```{r}
# graduation.R
# Simulating graduation, drop-out rate
init <- c(0,1,0,0,0,0) # student starts as freshman

state_names <-  c("Dropout","Fr","So","Jr","Se","Graduate")
P <- trans_matrix(state_names,
                  c(1, 0, 0, 0, 0, 0,0.06,0.03,0.91,0,0,0,0.06,0,0.03,0.91,0,0,0.04,0,0,0.03,0.93,0,0.04,0,0,0,0.03,0.93,0,0,0,0,0,1))
P
matrixpower(P, 1000)[, c('Dropout', 'Graduate')]
```

```{r}
(steps <- markov_most_likely(init,P,num_steps))
colnames(P)[steps]
```

```{r}

simulation <- markov(init,P,10,states)
state_names[simulation]
num_simulations <- 100000
sim <- replicate(num_simulations, markov(init, P, 10, state_names)[11])
#sim <- state_names[sim]
table(sim)/num_simulations
```

```{r}
(table(sim)/num_simulations)['Graduate']
matrixpower(P, 1000)['Fr', 'Graduate']
```

```{r}
example_2_19 <- new("markovchain", byrow = TRUE,
                 states = state_names, 
                 transitionMatrix = P,
                 name = "Example")
example_2_19
plot(example_2_19)
```


# Chapter 3


## Example 3.2

```{r}
# gym.R
# Example 3.2
# Markov simulation
states <- c("Aerobics","Massage","Weights","Yoga")
(P <- trans_matrix(states,
                   c(0.1,0.2,0.4,0.3,0.4,0,0.4,0.2,0.3,0.3,0,0.4,0.2,0.1,0.4,0.3)))

init <- c(1/4,1/4,1/4,1/4) # initial distribution
# simulate chain for 100 steps
simlist <- markov(init,P,100,states)
table(simlist)/100
steps <- 1000000
simlist <- markov(init,P,steps,states)
table(simlist)/steps

init <- c(1, 0, 0, 0) # initial distribution
simlist <- markov(init,P,steps,states)
table(simlist)/steps
```

## 3.2 Stationary Distribution

```{r}
limiting_distribution <- matrixpower(P, 1000)
(limiting_distribution <- limiting_distribution[1, ])

limiting_distribution %*% P
limiting_distribution %*% matrixpower(P, 2)
limiting_distribution %*% matrixpower(P, 10)
limiting_distribution %*% matrixpower(P, 1000)
```

```{r}
stationary <- function(mat) {
    x <- eigen(t(mat))$vectors[,1]
    x <- as.double(x/sum(x))
    names(x) <- colnames(mat)
    return (x)
}
```

```{r}
limiting_distribution
stationary(P)
```

```{r}
## Example where there is no stationary distirbution 

init <- c(0,1,0,0,0,0) # student starts as freshman

state_names <-  c("Dropout","Fr","So","Jr","Se","Graduate")
P <- trans_matrix(state_names,
                  c(1, 0, 0, 0, 0, 0,0.06,0.03,0.91,0,0,0,0.06,0,0.03,0.91,0,0,0.04,0,0,0.03,0.93,0,0.04,0,0,0,0.03,0.93,0,0,0,0,0,1))
matrixpower(P, 1000) # does not have a limiting distribution because not a positive transition matrix
(stationary_P <- stationary(P))
stationary_P %*% P  # not sure how to interpret this
```

```{r}
state_names <-  c("0 Fleas", "1 Flea", paste(2:5, "Fleas"))
P <- trans_matrix(state_names,
                  c(0, 1, 0, 0, 0, 0,
                    1/5, 0, 4/5, 0, 0, 0,
                    0, 2/5, 0, 3/5, 0, 0,
                    0, 0, 3/5, 0, 2/5, 0,
                    0, 0, 0, 4/5, 0, 1/5,
                    0, 0, 0, 0, 1, 0))
matrixpower(P, 1000)
matrixpower(P, 1001)
stationary(P)
sum(stationary(P))
```

## Example 3.15

```{r}
state_names <-  paste0("M", 2:5)
P <- trans_matrix(state_names,
                  c(0.785, 0.194, 0.018, 0.003,
                    0.615, 0.334, 0.048, 0.003,
                    0.578, 0.353, 0.069, 0.000,
                    0.909, 0.000, 0.091, 0.000))
matrixpower(P, 1000)
# what is the distribution of earthquakes?
# e.g. if there is an earthquake ~74% of the time it is an m2
# if an earthquake occurs once every 4 months (i.e. 3 times per year)
# we will 
stationary(P)
sum(stationary(P))

stationary(P) * 3  # per year

# 1 "visit" per every x steps
# M5 will occur once every 343 times.
(expected_visits <- 1 / stationary(P))

# how many years until another earthquake?
expected_visits * 4 / 12
```

## Example 3.21 (PageRank)

```{r}
# pagerank.R
# Example 3.21
# PageRank probabilities
states <- c("a","b","c","d","e","f","g")
(Q <- trans_matrix(states,
                   c(0,0,0,0,1/2,1/2,0,1/3,0,1/3,0,0,1/3,0,0,0,0,1/2,0,1/2,0,0,0,0,0,0,1,0,
                     1/4,0,0,1/4,0,1/4,1/4,1/2,1/2,0,0,0,0,0,1/7,1/7,1/7,1/7,1/7,1/7,1/7)))
stationary(Q)
(stationary(Q) %*% Q)[1,]
(A <- trans_matrix(states, rep(1/7,49)))
# transition matrix with damping factor p=0.85
(P <- 0.85*Q + 0.15*A)

# stationary probabilities
(pr <- stationary(P))
matrixpower(P, 1000)[1,]
```

## 3.8 Absorbing Chains

```{r}
P <- matrix(rep(0,101^2),nrow=101)
r <- function(row,inp) 
for (i in 1:6) {
	P[row+1,inp[i]+1] <<- P[row+1,inp[i]+1] + 1/6 }
 r(0,c(38,2,3,14,5,6))
 r(1,c(2,3,14,5,6,7))
 r(2,c(3,14,5,6,7,8))
 r(3,c(14,5,6,7,8,31))
 r(4,c(5,6,7,8,31,10))
 r(5,c(6,7,8,31,10,11))
 r(6,c(7,8,31,10,11,12))
 r(7,c(8,31,10,11,12,13))
 r(8,c(31,10,11,12,13,14))
 r(9,c(10,11,12,13,14,15))
 r(10,c(11,12,13,14,15,6))
 r(11,c(12,13,14,15,6,17))
 r(12,c(13,14,15,6,17,18))
 r(13,c(14,15,6,17,18,19))
 r(14,c(15,6,17,18,19,20))
 r(15,c(6,17,18,19,20,42))
 r(16,c(17,18,19,20,42,22))
 r(17,c(18,19,20,42,22,23))
 r(18,c(19,20,42,22,23,24))
 r(19,c(20,42,22,23,24,25))
 r(20,c(42,22,23,24,25,26))
 r(21,c(22,23,24,25,26,27))
 r(22,c(23,24,25,26,27,84))
 r(23,c(24,25,26,27,84,29))
 r(24,c(25,26,27,84,29,30))
 r(25,c(26,27,84,29,30,31))
 r(26,c(27,84,29,30,31,32))
 r(27,c(84,29,30,31,32,33))
 r(28,c(29,30,31,32,33,34))
 r(29,c(30,31,32,33,34,35))
 r(30,c(31,32,33,34,35,44))
 r(31,c(32,33,34,35,44,37))
 r(32,c(33,34,35,44,37,38))
 r(33,c(34,35,44,37,38,39))
 r(34,c(35,44,37,38,39,40))
 r(35,c(44,37,38,39,40,41))
 r(36,c(37,38,39,40,41,42))
 r(37,c(38,39,40,41,42,43))
 r(38,c(39,40,41,42,43,44))
 r(39,c(40,41,42,43,44,45))
 r(40,c(41,42,43,44,45,46))
 r(41,c(42,43,44,45,46,47))
 r(42,c(43,44,45,46,47,26))
 r(43,c(44,45,46,47,26,11))
 r(44,c(45,46,47,26,11,50))
 r(45,c(46,47,26,11,50,67))
 r(46,c(47,26,11,50,67,52))
 r(47,c(26,11,50,67,52,53))
 r(48,c(11,50,67,52,53,54))
 r(49,c(50,67,52,53,54,55))
 r(50,c(67,52,53,54,55,53))
 r(51,c(52,53,54,55,53,57))
 r(52,c(53,54,55,53,57,58))
 r(53,c(54,55,53,57,58,59))
 r(54,c(55,53,57,58,59,60))
 r(55,c(53,57,58,59,60,61))
 r(56,c(57,58,59,60,61,19))
 r(57,c(58,59,60,61,19,63))
 r(58,c(59,60,61,19,63,60))
 r(59,c(60,61,19,63,60,65))
 r(60,c(61,19,63,60,65,66))
 r(61,c(19,63,60,65,66,67))
 r(62,c(63,60,65,66,67,68))
 r(63,c(60,65,66,67,68,69))
 r(64,c(65,66,67,68,69,70))
 r(65,c(66,67,68,69,70,91))
 r(66,c(67,68,69,70,91,72))
 r(67,c(68,69,70,91,72,73))
 r(68,c(69,70,91,72,73,74))
 r(69,c(70,91,72,73,74,75))
 r(70,c(91,72,73,74,75,76))
 r(71,c(72,73,74,75,76,77))
 r(72,c(73,74,75,76,77,78))
 r(73,c(74,75,76,77,78,79))
 r(74,c(75,76,77,78,79,100))
 r(75,c(76,77,78,79,100,81))
 r(76,c(77,78,79,100,81,82))
 r(77,c(78,79,100,81,82,83))
 r(78,c(79,100,81,82,83,84))
 r(79,c(100,81,82,83,84,85))
 r(80,c(81,82,83,84,85,86))
 r(81,c(82,83,84,85,86,24))
 r(82,c(83,84,85,86,24,88))
 r(83,c(84,85,86,24,88,89))
 r(84,c(85,86,24,88,89,90))
 r(85,c(86,24,88,89,90,91))
 r(86,c(24,88,89,90,91,92))
 r(87,c(88,89,90,91,92,73))
 r(88,c(89,90,91,92,73,94))
 r(89,c(90,91,92,73,94,75))
 r(90,c(91,92,73,94,75,96))
 r(91,c(92,73,94,75,96,97))
 r(92,c(73,94,75,96,97,78))
 r(93,c(94,75,96,97,78,99))
 r(94,c(75,96,97,78,99,100))
 r(95,c(96,97,78,99,100,95))
 r(96,c(97,78,99,100,96,96))
 r(97,c(78,99,100,97,97,97))
 r(98,c(99,100,98,98,98,98))
 r(99,c(100,99,99,99,99,99))
 r(100,c(100,100,100,100,100,100))
 
colnames(P) <- as.character(0:100)
rownames(P) <- as.character(0:100)
```

```{r}
preview_matrix <- function(M) {
    num_rows <- nrow(M)
    num_cols <- ncol(M)
    row_indices <- unique(c(1:min(5, num_rows), max((num_rows-5), 1):num_rows))
    col_indices <- unique(c(1:min(5, num_cols), max((num_cols-5), 1):num_cols))
    return (M[row_indices, col_indices])
}
```

```{r}
preview_matrix(P)
```

Note that the matrix above is in the format of

```
P =  ( Q  |  R  )
       -------
       0  |  I
```

Where `t` states are transient states. `k - t` are absorbing states.

From text: `In the Snakes and Ladders Markov chain every state, except 100, is transient. State 100 is recurrent.`

Where 
    * `Q` is a `t x t` matrix.
    * `R` is a `t x (k - t)` matrix.
    * `0` is a `(k - t) x t` matrix of 0's.
    * `I` is the `(k - t) x (k - t)` identity matrix.

```{r}
transient_states <- 1:100
absorbing_states <- 101

Q <- P[transient_states, transient_states]
preview_matrix(Q)

R <- P[transient_states, absorbing_states]
R

zero <- P[absorbing_states, transient_states]
all.equal(as.numeric(zero), rep(0, length(transient_states)))
zero[c(1, 2, 3, 98, 99, 100, 101)]

I_m <- P[absorbing_states, absorbing_states]
I_m
```

P.g 125.. The `fundamental matrix` gives the expected number of visits to `j` given tha the chain starts in `i`.

```{r}
# solve returns inverse of matrix if `b` is not passed
fundamental_matrix <- solve(diag(length(transient_states)) - Q)  # change M to P... because M doesn't exist
preview_matrix(fundamental_matrix)
## absorbtion probabilities
```


```{r}
(fundamental_matrix %*% rep(1,100))[1:5,]
```

pg. 126 .... That is, the expected absorption times are the row sums of the fundamental matrix.

i.e. values below have same values as above. From starting point (index `0`), it takes, on average, `39.60` moves to treach the ending square (i.e. to get absorbed).

```{r}
rowSums(fundamental_matrix)
```


```{r}
# pg 123 "If the Markov chain has only one absorbing state, this submatrix will be a (k-1)-element
# column of vectors of 1s
(fundamental_matrix %*% R)[c(1:5, 95:100),]
```


```{r}
Q_absorb <- function(P, transient_states) {
    P[transient_states, transient_states]
}

R_absorb <- function(P, transient_states, absorbing_states) {
    P[transient_states, absorbing_states]
}
fundamental_matrix <- function(P, transient_states) {
    Q <- Q_absorb(P, transient_states)
    return (solve(diag(length(transient_states)) - Q))
}
```


```{r}
P <- trans_matrix(paste0("$", c(1:4, 0, 5)),
                  c(0.0, 0.6, 0.0, 0.0, 0.4, 0.0,
                    0.4, 0.0, 0.6, 0.0, 0.0, 0.0,
                    0.0, 0.4, 0.0, 0.6, 0.0, 0.0,
                    0.0, 0.0, 0.4, 0.0, 0.0, 0.6,
                    0.0, 0.0, 0.0, 0.0, 1.0, 0.0,
                    0.0, 0.0, 0.0, 0.0, 0.0, 1.0))
P
transient_states <- 1:4
absorbing_states <- 5:6

Q <- Q_absorb(P, transient_states)
Q

R <- R_absorb(P, transient_states, absorbing_states)
R

(fund_matrix <- fundamental_matrix(P, transient_states))

fund_matrix %*% R
```

```{r}
rowSums(fund_matrix)
```


```{r}
# If the gambler starts with $2, the probability of their eventual ruin is 0.36 (pg 124)
(fund_matrix %*% R)[2, ]
```


```{r}
# graduation.R
# Simulating graduation, drop-out rate
init <- c(0,1,0,0,0,0) # student starts as freshman

state_names <-  c("Dropout","Fr","So","Jr","Se","Graduate")
P <- trans_matrix(state_names,
                  c(1, 0, 0, 0, 0, 0,0.06,0.03,0.91,0,0,0,0.06,0,0.03,0.91,0,0,0.04,0,0,0.03,0.93,0,0.04,0,0,0,0.03,0.93,0,0,0,0,0,1))
P <- cbind(P[,2:5], P[,1], P[,6])
P <- rbind(P[2:5,], P[1,], P[6,])
state_names <-  c("Fr","So","Jr","Se", "Dropout", "Graduate")
colnames(P) <- state_names
rownames(P) <- state_names
P
```

```{r}
matrixpower(P, 1000)[, c('Dropout', 'Graduate')]
```

```{r}
transient_states <- 1:4
absorbing_states <- 5:6

Q <- Q_absorb(P, transient_states)
Q

R <- R_absorb(P, transient_states, absorbing_states)
R

(fund_matrix <- fundamental_matrix(P, transient_states))

fund_matrix %*% R
matrixpower(P, 1000)[c('Fr', 'So', 'Jr', 'Se'), c('Dropout', 'Graduate')]
```

```{r}
# expected number of steps until absorbed (in this case either dropout or grad)
rowSums(fund_matrix)
```


































