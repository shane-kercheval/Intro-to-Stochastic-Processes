---
title: "Wooldridge 7e - Appendix B - Math Refresher - Basic Tools"
author: "Shane Kercheval"
output:
  md_document:
    variant: markdown_github
    toc: true
    toc_depth: 4
---

```{r setup, echo=FALSE, warning = FALSE, message = FALSE}
#devtools::install_github('shane-kercheval/rtools')
library(ggplot2)
library(purrr)
library(scales)
library(stringr)
library(dplyr)
library(tidyr)
library(rtools)
library(forcats)

options(scipen=999) # non-scientific notation
theme_set(theme_light())
```

```{r}
matrixpower <- function(mat,k) {
    if (k == 0) {
      
        mat_diag <- diag(dim(mat)[1])
        rownames(mat_diag) <- rownames(mat)
        colnames(mat_diag) <- colnames(mat)
        return (mat_diag)  
    }
    if (k == 1) return(mat)
    if (k > 1) return( mat %*% matrixpower(mat, k-1))
}
```


# Appendix B - Probability Review

## Example B.2

```{r}
circumference <- function(r) {
    return (pi * r ^ 2)
}
radius <- c(1, 2, 4, 8)
probabilities <- c(0.1, 0.2, 0.3, 0.4)
(expected_value <- sum(circumference(radius) * probabilities))
expected_value / pi
```

```{r}
cal_expected_value <- function(.func, .values, .probabilities) {
    return ( sum(.func(.values) * .probabilities) )
}

all.equal(expected_value, cal_expected_value(circumference, radius, probabilities))
```


```{r}
(values <- circumference(radius))
var(values)
sd(values)
(variance <- sum((radius - expected_value)^2 * probabilities))
sqrt(variance)
```

hmmm.. pg 424 says this should be equivalent to above but i'm not getting the same answer 

```{r}
cal_expected_value(circumference, radius^2, probabilities) - expected_value^2
```

## Example B.5

```{r}
rt_plot_binom <- function(.num_observations, .probability) {
    data.frame(x = 0:.num_observations,
                  y = dbinom(0:.num_observations, .num_observations, prob = .probability)) %>%
        ggplot(aes(x=x, y=y)) +
        geom_col()
}
rt_plot_binom(100, 0.8) + geom_vline(aes(xintercept = 75), color='red')

sum(dbinom(0:100, 100, 0.8))
# sum each probability from 75 to 100
sum(dbinom(75:100, 100, 0.8))
# or, take the sum of probabilities from 1 to 74 and subtract it from 1
1 - sum(dbinom(1:74, 100, 0.8))
1 - pbinom(74, 100, 0.8)
```

```{r}
rt_plot_geom <- function(.num_observations, .probability) {
    data.frame(x = .num_observations,
               y = dgeom(.num_observations - 1, prob = .probability)) %>%
        ggplot(aes(x=x, y=y)) +
    geom_col() +
    scale_x_continuous(breaks = pretty_breaks(max(.num_observations) + 1)) +
    scale_y_continuous(labels=percent_format())
}
rt_plot_geom(1:10, 0.5) 
# 52 cards, 4 aces
# how many hands until first ace
rt_plot_geom(0:51, 4/52)
1/(4/52)
```

# Example B.6

Interested to see if I can simulate this and get ~same number from book.

```{r}
first_card_ace <- rbinom(1, 1, 4/52)
second_card_ace <- rbinom(1, 1, 4/51)
any(rbinom(1, 1, 4/52), rbinom(1, 1, 4/51))

num_deals <- 100
num_simulations <- 10000
simulations <- map(1:num_simulations,
                   ~ map_lgl(1:num_deals,
                             ~ any(rbinom(1, 1, 4/52), rbinom(1, 1, 4/51))))

mean(map_dbl(simulations, ~ which(. == 1)[1]))
```

```{r}
rt_plot_poisson <- function(.num_observations, .rate) {
    data.frame(x = .num_observations,
               y = dpois(.num_observations, .rate)) %>%
        ggplot(aes(x=x, y=y)) +
    geom_col() +
    scale_x_continuous(breaks = pretty_breaks(max(.num_observations) + 1)) +
    scale_y_continuous(labels=percent_format())
}
rt_plot_poisson(0:30, 21.7) 
dpois(14, 21.7)
ppois(14, 21.7)
```

## Example B.9

```{r}
blood_type_probabilities <- c(0.44, 0.42, 0.10, 0.04)
names(blood_type_probabilities) <- c("O", "A", "B", "AB")
blood_type_probabilities

snumber_of_people <- 6
# random selection of people
rmultinom(10, size = number_of_people, prob = blood_type_probabilities)
# probability (density) that, in a sample of 6 people, 
# 3 are O, 2 are A, 1 is B, and 0 are AB
dmultinom(c(3, 2, 1, 0), prob = blood_type_probabilities)
```

## Example B.10

```{r}
# probability component will lat more than 1300 hours
1 - pexp(1300, 1/1200)

1 - pexp(1, 1/2)
1 - pexp(2, 1/4)

# if the average tv last 5 years
# what is the probability it will last at least a year
1 - pexp(1, 1/5)
# so extended warranty is for the pexp(1, 1/5) chance it will not last more than a year
pexp(1, 1/5)
```


# Chapter 1

```{r}
rt_plot_binom <- function(.num_observations, .probability) {
    as.data.frame(x = 0:.num_observations,
                  y = dbinom(x, .num_observations, prob = .probability)) %>%
        ggplot(aes(x=x, y=y)) +
        geom_col()
}

reed_frost_probability_time_t <- function(.z, .I_t) {
    return (1 - (1 - .z)^.I_t)
}

reed_frost_probability_time_t(0.004, 3)

simulate_infected_t_next <- function(.susceptible_t,
                                     .infected_t,
                                     .infection_probability) {
    # simulate each person in the susceptible group either getting (1) or
    # not getting (0) the disease based on Reed-Frost probability
    return (rbinom(n=.susceptible_t,
                   size=1,
                   prob=reed_frost_probability_time_t(.infection_probability,
                                                      .infected_t)))
}
simulate_infected_t_next(400, 3, 0.004)

simulate_t_units <- function(.time_units=20,
                             .susceptible_init=400,
                             .infected_init=3,
                             .infection_probability=0.004) {

    .susceptible_t <- numeric(.time_units + 1)
    .infected_t <- numeric(.time_units + 1)
    
    .susceptible_t[1] <- .susceptible_init
    .infected_t[1] <- .infected_init

    for(.time in 1:.time_units) {
        newly_infected <- simulate_infected_t_next(.susceptible_t[.time],
                                                   .infected_t[.time],
                                                   .infection_probability)

        .infected_t[.time + 1] <- sum(newly_infected)
        .susceptible_t[.time + 1] <- .susceptible_t[.time] - .infected_t[.time + 1]
    }
    
    return (list(infected=.infected_t,
                 susceptible=.susceptible_t))
}
```

```{r}
simulate_t_units(20, 400, 3, 0.004)$infected %>% plot(type='b')
```

```{r fig.height=6, fig.width=9}
num_time_units <- 100
many_sims <- map(1:10000, ~ simulate_t_units(num_time_units, 400, 3, 0.004)$infected)

#many_sims[[1]]
sims_matrix <- matrix(unlist(many_sims), ncol = num_time_units + 1, byrow = TRUE)
#dim(sims_matrix)
#View(sims_matrix)
sims_df <- as.data.frame(sims_matrix)
quantile_low <- function(x) {
    quantile(x, 0.025)
}
quantile_high <- function(x) {
    quantile(x, 0.975)
}

data.frame(t=0:num_time_units,
           mean_val=apply(sims_matrix, 2, mean),
           median_val=apply(sims_matrix, 2, median),
           conf_low=apply(sims_matrix, 2, quantile_low),
           conf_high=apply(sims_matrix, 2, quantile_high)) %>%
    ggplot(aes(x=t, y=median_val)) +
    geom_point() +
    geom_point(aes(y=mean_val), color='blue') +
    geom_errorbar(aes(ymin=conf_low, ymax=conf_high)) +
    scale_y_continuous(breaks = pretty_breaks(10)) +
    coord_cartesian(xlim=c(0, 25), ylim=c(0, 70))

sims_long_df <- sims_df %>%
    mutate(sim=1:nrow(sims_df)) %>%
    pivot_longer(-sim, names_to = 'time_index', values_to = 'infected') %>%
    mutate(time_index = as.numeric(str_remove(time_index, 'V')))

sims_long_df %>%
    ggplot(aes(x = time_index, y = infected, group=sim)) +
    geom_line(alpha=0.01) +
    scale_y_continuous(breaks = pretty_breaks(10)) +
    coord_cartesian(xlim=c(0, 25), ylim=c(0, 70))

sims_long_df %>%
    ggplot(aes(x = time_index, y = infected)) +
    geom_jitter(alpha=0.01) +
    scale_y_continuous(breaks = pretty_breaks(10)) +
    coord_cartesian(xlim=c(0, 25), ylim=c(0, 70))

sims_long_df %>%
    ggplot(aes(x = time_index, y = infected, group=time_index)) +
    geom_boxplot() +
    scale_y_continuous(breaks = pretty_breaks(10)) +
    coord_cartesian(xlim=c(0, 25), ylim=c(0, 70))
```

## Example 1.12

```{r fig.height=9, fig.width=12}
number_of_simulations <- 10000
X <- round(runif(number_of_simulations, min=0.50001, max=100.499999))
plot(table(X) / number_of_simulations)
Y <- map_dbl(X, ~ round(runif(1, min=0.50001, max= . + 0.499999)))
# Distribution of Y
plot(table(Y) / number_of_simulations)

data.frame(x=X, y=Y) %>%
    ggplot(aes(x=x, y=y)) +
    geom_jitter(alpha=0.5)

data.frame(x=X, y=Y) %>%
    ggplot(aes(x=x, y=y, group=x)) +
    geom_boxplot()
#sum(table(Y) / number_of_simulations)

# distribution of Y given X?
plot(1:100, 1 / (1:100), type = 'h')
```

Same thing implemented differently

```{r fig.height=9, fig.width=12}
number_of_simulations <- 10000
X <- sample(1:100, size = number_of_simulations, replace = TRUE)
plot(table(X) / number_of_simulations)
Y <- map_dbl(X, ~ sample(1:., size = 1, replace = TRUE))
# Distribution of Y
plot(table(Y) / number_of_simulations)

data.frame(x=X, y=Y) %>%
    ggplot(aes(x=x, y=y)) +
    geom_jitter(alpha=0.5)

data.frame(x=X, y=Y) %>%
    ggplot(aes(x=x, y=y, group=x)) +
    geom_boxplot()
#sum(table(Y) / number_of_simulations)

# distribution of Y given X?
plot(1:100, 1 / (1:100), type = 'h')
```

## Example 1.21

```{r}
(flips <- rbinom(100, 1, 0.5))
(rolling_sum <- rollapplyr(flips, width = 2, FUN = sum, partial = TRUE))
which(rolling_sum == 2)
```

```{r}
num_simulations <- 10000
num_flips_until_2_heads <- map_dbl(1:num_simulations, ~ which(rollapplyr(rbinom(100, 1, 0.5), width = 2, FUN = sum, partial = TRUE) == 2)[1])
mean(num_flips_until_2_heads)
hist(num_flips_until_2_heads, breaks = max(num_flips_until_2_heads))
```

Note that expecte value is `6` (i.e the average of all the simulations i.e. in the long run.), even though `2` is the most probabilistic. 

## Example 1.31

```{r fig.height=9, fig.width=12}
number_of_simulations <- 100000
X <- runif(number_of_simulations, min=0, max=1)
Y <- map_dbl(X, ~ runif(1, min=0, max= .))
# Distribution of Y

data.frame(x=X, y=Y) %>%
    ggplot(aes(x=x, y=y)) +
    geom_jitter(alpha=0.5)

mean(Y)
var(Y)
```

From Book

```{r}
trials <- 100000
simlist <- replicate(trials, runif(1, 0, runif(1)))
var(simlist)
```

## Exercise 1.35

```{r}
# gamble(k, n, p)
  #   k: Gambler's initial state
  #   n: Gambler plays until either $n or Ruin
  #   p: Probability of winning $1 at each play
  #   Function returns 1 if gambler is eventually ruined
  #                    returns 0 if gambler eventually wins $n
  
gamble <- function(k,n,p) {
	stake <- k
	while (stake > 0 & stake < n) {
		bet <- sample(c(-1,1), 1, prob=c(1-p, p))
		stake <- stake + bet
	}
	if (stake == 0) return(1) else return(0)
}   

k <- 60
n <-  100  
p <- 0.50 
trials <- 10000
simlist <- replicate(trials, gamble(k, n, p))

mean(simlist) # Estimate of probability that gambler is ruined
1 - mean(simlist)# Estimate of probability that the gambler wins $100

p <- 0.51
trials <- 10000
simlist <- replicate(trials, gamble(k, n, p))

mean(simlist) # Estimate of probability that gambler is ruined
1 - mean(simlist)# Estimate of probability that the gambler wins $100

```

# Chapter 2

```{r}
trans_matrix <- function(.names, .values) {
    P <- matrix(ncol = length(.names), 
            byrow = TRUE, dimnames = list(.names, .names),
            data=.values)
    
    stopifnot(all.equal(as.numeric(rowSums(P)), rep(1, length(.names))))
    return (P)
}
```

## Example 2.15

```{r}
P <- trans_matrix(c("Rain", "Snow", "Clear"),
                  c(0.2, 0.6, 0.2,
                    0.1, 0.8, 0.1,
                    0.1, 0.6, 0.3))
P
matrixpower(P, 2)

initial_state <- c(0.5, 0.5, 0)
(probability_day_2 <- initial_state %*% matrixpower(P, 2))
probability_day_2[1, 'Snow']
```


## Example 2.16

```{r}

P <- trans_matrix(c("B", "F", "P", "S"),
                  c(0.0, 0.5, 0.5, 0.0,
                    0.5, 0.0, 0.5, 0.0,
                    0.4, 0.0, 0.0, 0.6,
                    0.0, 0.2, 0.6, 0.2))
P
(P_2 <- matrixpower(P, 2))
(P_3 <- matrixpower(P, 3))

(alpha <- rep(0.25, 4))

(alpha %*% P_3)[1, 'S']
P_2['S', 'S']
P['S', 'P']

(alpha %*% P_3)[1, 'S'] * P_2['S', 'S'] * P['S', 'P']
```


```{r}
P_2['P', 'F']
```

## Using `markovchain` library

```{r}
library(markovchain)
weatherStates <- c("sunny", "cloudy", "rain")
weatherMatrix <- matrix(data = c(0.70, 0.2, 0.1,
                                 0.3, 0.4, 0.3,
                                 0.2, 0.45, 0.35),
                        byrow = TRUE,
                        nrow = length(weatherStates),
                        dimnames = list(weatherStates, weatherStates))
mcWeather <- new("markovchain", states = weatherStates, byrow = TRUE,
                 transitionMatrix = weatherMatrix, name = "Weather")

weatherStates <- c("sunny", "cloudy", "rain")
weatherMatrix <- trans_matrix(weatherStates,
                              c(0.70, 0.2, 0.1,
                                 0.3, 0.4, 0.3,
                                 0.2, 0.45, 0.35))
mcWeather <- new("markovchain", states = weatherStates, transitionMatrix = weatherMatrix, byrow = TRUE,
                 name = "Weather")
mcWeather
plot(mcWeather)
```

Shown below, the markovchain object changes the power operation so that it works with Matrices. It also changes the multiplication operation to dot product.

```{r}
weatherMatrix ^ 7  # not correct way
matrixpower(weatherMatrix, 7)  # correct
mcWeather ^ 7  # correct
```

```{r}
initialState <- c(0, 1, 0)
initialState * weatherMatrix  # regular multiplication
initialState %*% weatherMatrix  # dot product
initialState * mcWeather  # dot product
```

```{r}
initialState <- c(0, 1, 0)

(after2Days <- initialState * (mcWeather * mcWeather))
stopifnot(all.equal(sum(after2Days), 1))
(after7Days <- initialState * (mcWeather ^ 7))
```

```{r}
(probability_day_2 <- initialState %*% matrixpower(weatherMatrix, 2))
stopifnot(all.equal(sum(probability_day_2), 1))

(probability_day_7 <- initialState %*% matrixpower(weatherMatrix, 7))
```

```{r}
state_names <- c("Burrito", "Falafel", "Pizza", "Sushi")
P <- trans_matrix(state_names,
                  c(0.0, 0.5, 0.5, 0.0,
                    0.5, 0.0, 0.5, 0.0,
                    0.4, 0.0, 0.0, 0.6,
                    0.0, 0.2, 0.6, 0.2))
example_2_16 <- new("markovchain", byrow = TRUE,
                 states = state_names, 
                 transitionMatrix = P,
                 name = "Example")
example_2_16
plot(example_2_16)
```

```{r}
# function from https://cran.r-project.org/web/packages/markovchain/vignettes/an_introduction_to_markovchain_package.pdf
fvals <- function(mchain,initialstate,n) {
    out <- data.frame()
    names(initialstate) <- names(mchain)
    for (i in 0:n) {
        iteration <- initialstate*mchain^(i)
        out <- rbind(out,iteration)
    }
    out <- cbind(out, i=seq(0,n))
    out <- out[,c(4,1:3)]
    return(out)
}
fval_iterations_1 <- fvals(mchain=mcWeather,initialstate=c(1/3, 1/3, 1/3), n=20)
fval_iterations_2 <- fvals(mchain=mcWeather,initialstate=c(1, 0, 0), n=20)

# ~same values even though they started with different initial states
tail(fval_iterations_1, 1)
tail(fval_iterations_2, 1)
all.equal(as.numeric(tail(fval_iterations_1, 1)), as.numeric(tail(fval_iterations_2, 1)))
```

```{r}
matrixpower(P, 100)
```

```{r}
initial_state <- c(0, 0, 1, 0)
initial_state %*% P
t(P) * initial_state
    
initial_state %*% P^3

matrixpower(P, 3)
(t(P) ^ 3)
    

fvals(mchain=mcWeather,initialstate=c(90,5,5),n=4)

```


# Calculating Transition Matrix From Data

```{r}
# https://stackoverflow.com/questions/18824596/how-to-create-a-transition-matrix-in-r

# assuming the data is read into a data frame called "raindata"
raindata <- tribble(
    ~day,~month,~year,~rainfall,
    1,01,1950,0.586212158,
    2,01,1950,1.202758789,
    3,01,1950,0,
    4,01,1950,0,
    5,01,1950,0,
    6,01,1950,0.183441162,
    7,01,1950,4.675704956,
    8,01,1950,9.258003235,
    9,01,1950,3.425468445,
    10,01,1950,0,
    11,01,1950,0,
    12,01,1950,8.39233E-05,
    13,01,1950,0,
    14,01,1950,0,
    15,01,1950,0.641731262,
    16,01,1950,9.325141907,
    17,01,1950,5.588417053,
    18,01,1950,0.903343201,
    19,01,1950,3.892127991,
    20,01,1950,0.133895874,
    21,01,1950,0.102630615,
    22,01,1950,5.334564209,
    23,01,1950,1.017593384,
    24,01,1950,0,
    25,01,1950,0.621734619,
    26,01,1950,0.957794189,
    27,01,1950,3.131622314,
    28,01,1950,4.868865967,
    29,01,1950,0.169281006,
    30,01,1950,0,
    31,01,1950,0)

rf <- raindata$rainfall
n <- length(rf)
rainedf <- as.factor(ifelse(rf,0,1))
trf_df <- data.frame(yesterday=rainedf[1:(n-1)],today=rainedf[2:n])
trf_freq <- table(trf_df)
trf_prob <- trf_freq/rowSums(trf_freq)

rowSums(trf_prob)

# probability it will not rain today given it rained yesterday
# row 2 column 1
trf_prob[2, 1]
# same thing
sum(trf_df$today == 0 & trf_df$yesterday == 1) / sum(trf_df$yesterday == 1)
```


## 2.5 Simulation

```{r}
markov <- function(init, mat, n, labels) { 
    if (missing(labels)) {
        labels <- 1:length(init)
    }
        
    simlist <- numeric(n+1)
    states <- 1:length(init)
    # initial state (e.g. where the cancer starts) based on initial probability distribution
    simlist[1] <- sample(states, 1, prob=init)
    for (i in 2:(n+1)) {
        
        previous_simulation <- simlist[i-1]
        prob_distribution_given_previous <- mat[previous_simulation, ]
        # simulate currrent state (e.g. where cancer will spread next) based on previous state (where cancer spread to last)
        # based on the probability distribution for that previous state
        simlist[i] <- sample(states, 1, prob=prob_distribution_given_previous)
    }
    
    return (labels[simlist])
}
```

```{r}
P <- read.csv("original\ code/lungcancer.csv",header=T)
P <- as.matrix(P)
rownames(P) <- colnames(P)
P
init <- c(rep(0,22),1,rep(0,27)) # Starting state 23 is Lung
names(init) <- colnames(P)
num_steps <- 8
```


```{r}
long_term <- matrixpower(P, 1000)[1, ]
data.frame(long_term_percent=long_term,
           part=names(long_term)) %>%
    mutate(part = fct_reorder(part, long_term_percent)) %>%
    filter(long_term_percent > 0) %>%
    ggplot(aes(x = part, y = long_term_percent)) +
    geom_col() +
    coord_flip()
```


```{r}
(simulation <- markov(init,P,num_steps))
colnames(P)[simulation]
```

```{r}
results <- map(1:10000, ~  colnames(P)[markov(init,P,num_steps)])
```

```{r}
data.frame(part=unlist(flatten(results))) %>%
    count(part) %>%
    mutate(perc = n / sum(n)) %>%
    mutate(part = fct_reorder(part, perc)) %>%
    ggplot(aes(x = part, y = perc)) +
    geom_col() +
    coord_flip()
    #theme(axis.text.x=element_text(angle=30, hjust=1)) 
    
```

```{r}
simulations <- matrix(unlist(results), ncol = num_steps + 1, byrow = TRUE)
head(simulations)
simulations <- as.data.frame(simulations)
colnames(simulations) <- paste("Step", 1:ncol(simulations))
head(simulations)
```

```{r fig.height=6, fig.width=9}
library(tidytext)
simulations %>%
    mutate(sim_index = row_number()) %>%
    pivot_longer(-sim_index, names_to = 'step', values_to='body_part') %>%
    group_by(step, body_part) %>%
    summarise(n=n(),
              perc_n = n() / nrow(simulations)) %>%
    ungroup() %>%
    filter(step != 'Step 1') %>%
    mutate(body_part = reorder_within(body_part, n, step)) %>%
    ggplot(aes(x = body_part, y=perc_n)) + #, fill=body_part)) +
    geom_col() +
    scale_x_reordered() +
    coord_flip() +
    #scale_fill_manual(values=rep(rt_colors(), 30)) +
    theme(legend.position = 'none') +
    facet_wrap(~ step, scales = 'free')
```

```{r fig.height=6, fig.width=9}
simulations %>%
    mutate(sim_index = row_number()) %>%
    pivot_longer(-sim_index, names_to = 'step', values_to='body_part') %>%
    group_by(step, body_part) %>%
    summarise(n=n(),
              perc_n = n() / nrow(simulations)) %>%
    ungroup() %>%
    filter(step != 'Step 1') %>%
    mutate(body_part = fct_reorder(body_part, n, .fun = max)) %>%
    ggplot(aes(x = body_part, y=perc_n, fill=body_part)) +
    geom_col() +
    coord_flip() +
    scale_fill_manual(values=rep(rev(rt_colors()), 30)) +
    theme(legend.position = 'none') +
    facet_wrap(~ step, scales = 'free')
```

```{r}
markov_most_likely <- function(init, mat, n, labels) { 
    if (missing(labels)) {
        labels <- 1:length(init)
    }
        
    simlist <- numeric(n+1)
    states <- 1:length(init)
    # initial state (e.g. where the cancer starts) based on initial probability distribution
    
    #simlist[1] <- sample(states, 1, prob=init)
    simlist[1] <- which.max(init)[1]
    for (i in 2:(n+1)) {
        
        previous_simulation <- simlist[i-1]
        prob_distribution_given_previous <- mat[previous_simulation, ]
        simlist[i] <- which.max(prob_distribution_given_previous)[1]
        
        # simulate currrent state (e.g. where cancer will spread next) based on previous state (where cancer spread to last)
        # based on the probability distribution for that previous state
        #simlist[i] <- sample(states, 1, prob=prob_distribution_given_previous)
    }
    return (labels[simlist])
}

# not sure how great or useful this is, but this simply gives the most probable outcome at each step based on the previous/initial
# in reality, this exact path may or may not actually have a high chance of occuring (especially with the lung cancer example where there are many posible combinations)
diag(P) <- 0
(steps <- markov_most_likely(init,P,num_steps))
colnames(P)[steps]
# not useful...... in this example might be useful in other examples where you can't go back to previous states
```

## Example 2.19

```{r}
# graduation.R
# Simulating graduation, drop-out rate
init <- c(0,1,0,0,0,0) # student starts as freshman

state_names <-  c("Dropout","Fr","So","Jr","Se","Graduate")
P <- trans_matrix(state_names,
                  c(1, 0, 0, 0, 0, 0,0.06,0.03,0.91,0,0,0,0.06,0,0.03,0.91,0,0,0.04,0,0,0.03,0.93,0,0.04,0,0,0,0.03,0.93,0,0,0,0,0,1))
P
matrixpower(P, 1000)[, c('Dropout', 'Graduate')]
```

```{r}
(steps <- markov_most_likely(init,P,num_steps))
colnames(P)[steps]
```

```{r}

simulation <- markov(init,P,10,states)
state_names[simulation]
num_simulations <- 100000
sim <- replicate(num_simulations, markov(init, P, 10, state_names)[11])
#sim <- state_names[sim]
table(sim)/num_simulations
```

```{r}
(table(sim)/num_simulations)['Graduate']
matrixpower(P, 1000)['Fr', 'Graduate']
```

```{r}
example_2_19 <- new("markovchain", byrow = TRUE,
                 states = state_names, 
                 transitionMatrix = P,
                 name = "Example")
example_2_19
plot(example_2_19)
```


# Chapter 3


## Example 3.2

```{r}
# gym.R
# Example 3.2
# Markov simulation
states <- c("Aerobics","Massage","Weights","Yoga")
(P <- trans_matrix(states,
                   c(0.1,0.2,0.4,0.3,0.4,0,0.4,0.2,0.3,0.3,0,0.4,0.2,0.1,0.4,0.3)))

init <- c(1/4,1/4,1/4,1/4) # initial distribution
# simulate chain for 100 steps
simlist <- markov(init,P,100,states)
table(simlist)/100
steps <- 1000000
simlist <- markov(init,P,steps,states)
table(simlist)/steps

init <- c(1, 0, 0, 0) # initial distribution
simlist <- markov(init,P,steps,states)
table(simlist)/steps
```

## 3.2 Stationary Distribution

```{r}
limiting_distribution <- matrixpower(P, 1000)
(limiting_distribution <- limiting_distribution[1, ])

limiting_distribution %*% P
limiting_distribution %*% matrixpower(P, 2)
limiting_distribution %*% matrixpower(P, 10)
limiting_distribution %*% matrixpower(P, 1000)
```

```{r}
stationary <- function(mat) {
    x = eigen(t(mat))$vectors[,1]
    as.double(x/sum(x))
}
```

```{r}
limiting_distribution
stationary(P)
```

```{r}
## Example where there is no stationary distirbution 

init <- c(0,1,0,0,0,0) # student starts as freshman

state_names <-  c("Dropout","Fr","So","Jr","Se","Graduate")
P <- trans_matrix(state_names,
                  c(1, 0, 0, 0, 0, 0,0.06,0.03,0.91,0,0,0,0.06,0,0.03,0.91,0,0,0.04,0,0,0.03,0.93,0,0.04,0,0,0,0.03,0.93,0,0,0,0,0,1))
matrixpower(P, 1000) # does not have a limiting distribution because not a positive transition matrix
(stationary_P <- stationary(P))
stationary_P %*% P  # not sure how to interpret this
```

```{r}
state_names <-  c("0 Fleas", "1 Flea", paste(2:5, "Fleas"))
P <- trans_matrix(state_names,
                  c(0, 1, 0, 0, 0, 0,
                    1/5, 0, 4/5, 0, 0, 0,
                    0, 2/5, 0, 3/5, 0, 0,
                    0, 0, 3/5, 0, 2/5, 0,
                    0, 0, 0, 4/5, 0, 1/5,
                    0, 0, 0, 0, 1, 0))
matrixpower(P, 1000)
matrixpower(P, 1001)
stationary(P)
sum(stationary(P))
```











































